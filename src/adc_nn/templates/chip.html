<!DOCTYPE html>
<html>
<head>
    <title>Base64 Image Example</title>
</head>
<body>
    <p><a href="{{data.meta.back_url}}">back</a> </p>
    <h3>{{data.meta.ab_type}}: {{data.meta.ab_conc}} {{data.meta.ab_unit}} (#{{data.meta.stack_index}})</h3>
    <p>{{data.meta.path}}</p>
    <p><a href="{{data.meta.prev_chip}}">prev</a> | <a href="{{data.meta.next_chip}}">next</a></p>
    <canvas id="myCanvas"></canvas>

    <script>
      // console.log({data});
      const DEFAULT_CIRCLE_COLOR = "#ffffff60";
      const jsdata = {{data | tojson}};
      console.log(jsdata);
      const {imgData: img, meta} = jsdata;
      console.log(img);
      console.log(meta);

      const canvas = document.getElementById("myCanvas");
      const context = canvas.getContext("2d");
      
      const image = new Image();
      image.src = `data:image/jpeg;base64,${img.value}`;
      
      const circles = meta.centers;
      const chip_id = meta.chip_id;
      const features = meta.features;
      console.log(features);

      circles.map(circle => circle.color = DEFAULT_CIRCLE_COLOR)
      features.map(({table_id, droplet_id, feature_id}) => {
        circles[droplet_id - 1].color="blue";
        circles[droplet_id - 1].table_id=table_id;
      });

      image.onload = () => {
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        redraw();
        
        // Add click event listener to the canvas
        canvas.addEventListener("click", (event) => {
            const x = event.clientX - canvas.offsetLeft;
            const y = event.clientY - canvas.offsetTop;
            circles.forEach(circle => {
                if (isPointInsideCircle(x, y, circle)) {
                  if (circle.color != "blue") {
                    circle.color = "blue";
                    console.log(`Add ${circle.id}`);
                    redraw();
                    post(1,chip_id,circle.id,4, 1).then(console.log).catch(console.log)
                  }else{
                    circle.color = DEFAULT_CIRCLE_COLOR;
                    console.log(`Remove ${circle.id}`);
                    redraw();
                    remove(chip_id,circle.id).then(console.log).catch(console.log)
                  }
                }
            });
        });
      };
      function drawCircle(circle) {
        context.beginPath();
        context.arc(circle.x, circle.y, circle.size / 2, 0, 2 * Math.PI);
        context.strokeStyle = circle.color;
        context.lineWidth = 2;
        context.stroke();
      }
      
      function isPointInsideCircle(x, y, circle) {
        const distance = Math.sqrt((x - circle.x) ** 2 + (y - circle.y) ** 2);
        return distance <= circle.size / 2;
      }
      
      function redraw() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(image, 0, 0);
        circles.forEach(circle => drawCircle(circle));
      }
      
      // Add click event listener to the canvas
      
      
      // Resize canvas when the window is resized
      window.addEventListener("resize", () => {
        canvas.width = image.width;
        canvas.height = image.height;
        redraw();
      });

      async function post(userId, chipId, dropletId, featureId, value){
        rep = await fetch("/droplet/feature/save", {
            method: "POST",
            body: JSON.stringify({
                user_id: userId,
                chip_id: chipId,
                droplet_id: dropletId,
                feature_id: featureId,
                value: value
            }),
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
        });
        return {rep};
      }
      async function remove(chip_id, circle_id){
        rep = await fetch("/droplet/feature/remove", {
            method: "POST",
            body: JSON.stringify({
              chip_id: chip_id,
              droplet_id: circle_id
            }),
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
        });
        return {rep};
      }

    </script>
    <!-- <ul>
        {% for d in data %}
            <li><img id="my-image" src="data:image/jpeg;base64,{{d.data}}" alt={{d.name}}></li>
        {% endfor %}
    </ul> -->
    <p><a href="{{data.meta.prev_chip}}">prev</a> | <a href="{{data.meta.next_chip}}">next</a></p>
    
</body>
</html>
